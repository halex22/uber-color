const MIN_COLOR = 0;
const MAX_COLOR = 255;
const randomBetween = () =>
  MIN_COLOR + Math.floor(Math.random() * (MAX_COLOR - MIN_COLOR + 1));
const randomAlpha = () => Math.round(Math.random() * 100) / 100;

const rgbToHsl = (r, g, b) => {
  r /= 255;
  g /= 255;
  b /= 255;
  const l = Math.max(r, g, b);
  const s = l - Math.min(r, g, b);
  const h = s
    ? l === r
      ? (g - b) / s
      : l === g
      ? 2 + (b - r) / s
      : 4 + (r - g) / s
    : 0;
  return [
    Math.round(60 * h < 0 ? 60 * h + 360 : 60 * h),
    Math.round(
      100 * (s ? (l <= 0.5 ? s / (2 * l - s) : s / (2 - (2 * l - s))) : 0)
    ),
    Math.round((100 * (2 * l - s)) / 2),
  ];
};

const hslToRgb = (h, s, l) => {
  s /= 100;
  l /= 100;
  const k = (n) => (n + h / 30) % 12;
  const a = s * Math.min(l, 1 - l);
  const f = (n) =>
    l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
  return [
    Math.round(255 * f(0)),
    Math.round(255 * f(8)),
    Math.round(255 * f(4)),
  ];
};


class UColor {
  /**
   *
   * @param {number} r
   * @param {number} g
   * @param {number} b
   * @param {number} a
   */
  constructor(r, g, b, a = 1) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
    this.colorsArray = [r, g, b];
  }

  // coverts string into UColor instance  --- DONE !!!
  /**
   *
   * @param {string} hexStr
   * @returns
   */
  static fromHexCode(hexStr) {
    const cleanedHexStr = hexStr.slice(1);
    const arrayOfStr = [...cleanedHexStr];
    const groupOfCouples = [];

    while (arrayOfStr.length > 0) {
      const coupleStrArray = arrayOfStr.splice(0, 2);
      groupOfCouples.push(coupleStrArray.join(""));
    }

    const parsedCouples = groupOfCouples.map((couple) => parseInt(couple, 16));
    if (parsedCouples[3]) {
      parsedCouples[3] = Math.round((parsedCouples[3] / 255) * 100) / 100;
    }

    return new UColor(...parsedCouples);
  }

  //  --- DONE !!!
  /**
   * The function `random` generates a random color with an optional alpha value.
   * @param {number} alpha - The `alpha` parameter in the `random` function is used to specify the alpha
   * (transparency) value of the color. If a value is provided for `alpha`, it will be used as the
   * alpha value for the color. If no value is provided for `alpha`, a random alpha value
   * @returns {UColor} A new `UColor` object is being returned, with the RGB values generated by the
   * `randomBetween()` function for red, green, and blue channels, and the alpha value either provided
   * as an argument or generated by the `randomAlpha()` function.
   */
  static random(alpha) {
    const colors = [randomBetween(), randomBetween(), randomBetween()];
    colors.push(alpha ? alpha : randomAlpha());
    return new UColor(...colors);
  }

  // -- DONE !!!
  /**
   * The function `fromRGB` takes a string in the format `rgba(r,g,b,a)` and returns a new `UColor`
   * object with the corresponding color values.
   * @param {string} RGBStr - The `RGBStr` parameter is a string representing an RGB color in the format
   * `rgba(r,g,b,a)`, where:
   * @returns {UColor} An instance of the `UColor` class with the RGB values extracted from the `RGBStr` string.
   */
  static fromRGB(RGBStr) {
    // rgba(255,61,12,0.5)')
    const splittedArray = RGBStr.split("(");
    const colorArraysStr = splittedArray[1].split(")")[0].split(",");
    const colorsArrayInt = colorArraysStr.map((color) => parseFloat(color));
    return new UColor(...colorsArrayInt);
  }

  // string --- DONE !!!
  toHex() {
    const r = this.r.toString(16).padStart(2, "0");
    const g = this.g.toString(16).padStart(2, "0");
    const b = this.b.toString(16).padStart(2, "0");
    // prima 0 - 1 a 0 - 255 e poi base 16
    const a = Math.round(this.a * 255)
      .toString(16)
      .padStart(2, "0");
    return `#${r}${g}${b}${a}`;
  }

  // string  --- DONE !!!
  /**
   * The `toRGB()` function returns the RGBA color values in a string format.
   * @returns {string} The `toRGB()` method is returning a string in the format `rgba(r, b, g, a)` where `r`,
   * `b`, `g`, and `a` are the values of the red, blue, green, and alpha components respectively of the
   * object calling the method.
   */
  toRGB() {
    return `rgba(${this.r},${this.b},${this.g}, ${this.a})`;
  }

  // -- DONE !!!
  /**
   * The function `getGrayColor` calculates the grayscale value of a color based on its RGB values.
   * @returns {UColor} A new `UColor` object is being returned with the RGB values converted to a grayscale
   * color. The RGB values are calculated based on the formula `gray = red * 0.3 + green * 0.59 + blue
   * * 0.11`, and then the grayscale value is applied to all RGB components while keeping the alpha
   * value unchanged.
   */
  getGrayColor() {
    const red = Math.round(this.r * 0.3);
    const green = Math.round(this.g * 0.59);
    const blue = Math.round(this.b * 0.11);

    const gray = red + green + blue;

    const arrayGrey = [gray, gray, gray, this.a];

    return new UColor(...arrayGrey);
  }


  getPalette() {
    const hslVersion = rgbToHsl(...this.colorsArray);
    const hue = hslVersion[0];
    const s = hslVersion[1];
    const l = hslVersion[2];
    const Palette = [new UColor(this.colorsArray)]
    const movements = 120

    for (let i = 0; i < 2; i++) {
      const newHue = (hue + (movements * (1 + i))) % 360;
      const newHsl = [newHue, s, l]
      const newColor  = hslToRgb(...newHsl)
      Palette.push(new UColor(...newColor))
    }
    // const newHue = (hue + 120) % 360;

    return Palette
  }



  /**
   * The function `getContrastColor` calculates a contrasting color based on the input RGB color array.
   * @returns {UColor} A new `UColor` object with the RGB values of the color that is the contrast of the
   * original color.
   */
  getContrastColor() {

    const hslVersion = rgbToHsl(...this.colorsArray);
    const hue = hslVersion[0];
    const newHue = (hue + 180) % 360;
    const l = hslVersion[2];
    let newLuminosity = l
    if (l < 20 || l > 80) {
      newLuminosity = 100 - l;
    }
    const newHsl = [newHue, hslVersion[1], newLuminosity]
    const contrastedRGB = hslToRgb(...newHsl)
    return new UColor(...contrastedRGB)
  }

}

const bohColor = UColor.fromHexCode("#ff3400");
console.log(bohColor);

// const uColor1 = new UColor()
// const uColor2 = UColor.fromHexCode('#ff3400')
// const uColor3 = UColor.random()
// console.log(uColor3)
// const uColor4 = UColor.fromRGB('rgba(255,61,12,0.5)')
// const uColor4Hex = UColor.
// #ff3d0c80
// const uColor4 = UColor.fromRGB('rgba(5,21,12,0.98)')
// console.log(uColor4.toRGB())
// const uColor5 = UColor.fromRGB('rgb(255,61,12)')
// const uColor6=  UColor.fromRGB('rgb(12, 255, 89)')
// console.log(uColor4.toHex())
// const uColor7 = uColor4.getGrayColor()
// console.log(uColor7.toRGB());

// console.log(uColor2.toHex()) // #ff3400
// console.log(uColor2.toHex()) // rgba(255,52,0,1)
// console.log(uColor2.getContrastColor())
// console.log(uColor2.getPalette())
// rgb(255, 10, 177)

const greenColor = new UColor(12, 255, 89)
const contrastedGreenColor = greenColor.getContrastColor()
console.log(greenColor)
console.log(contrastedGreenColor)
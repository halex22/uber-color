const MIN_COLOR = 0;
const MAX_COLOR = 255;
const randomBetween = () => MIN_COLOR + Math.floor(Math.random() * (MAX_COLOR - MIN_COLOR + 1));
const randomAlpha = () => Math.round(Math.random() * 100) / 100



class UColor {
  
  /**
   * 
   * @param {number} r 
   * @param {number} g 
   * @param {number} b 
   * @param {number} a 
   */
  constructor(r, g, b, a = 1) {
    this.r = r
    this.g = g
    this.b = b
    this.a = a
    // this.colorsArray = [r, g, b, a]
  }

  // coverts string into UColor instance  --- DONE !!!
  /**
   * 
   * @param {string} hexStr 
   * @returns 
   */
  static fromHexCode(hexStr) {
    const cleanedHexStr = hexStr.slice(1);
    const arrayOfStr = [...cleanedHexStr];
    const groupOfCouples = [];

    while (arrayOfStr.length > 0) {
      const coupleStrArray = arrayOfStr.splice(0, 2);
      groupOfCouples.push(coupleStrArray.join(''));
    }

    const parsedCouples = groupOfCouples.map(couple => parseInt(couple, 16));
    if (parsedCouples[3]) {
      parsedCouples[3] = Math.round(parsedCouples[3] / 255 *100)/100;
    }

    return new UColor(...parsedCouples)
  }

  //  --- DONE !!!
  /**
   * The function `random` generates a random color with an optional alpha value.
   * @param {number} alpha - The `alpha` parameter in the `random` function is used to specify the alpha
   * (transparency) value of the color. If a value is provided for `alpha`, it will be used as the
   * alpha value for the color. If no value is provided for `alpha`, a random alpha value
   * @returns {UColor} A new `UColor` object is being returned, with the RGB values generated by the
   * `randomBetween()` function for red, green, and blue channels, and the alpha value either provided
   * as an argument or generated by the `randomAlpha()` function.
   */
  static random(alpha) {
    const colors = [randomBetween(), randomBetween(), randomBetween()]
    colors.push(alpha ? alpha : randomAlpha())
    return new UColor(...colors)
  }


  /**
   * The function `fromRGB` takes a string in the format `rgba(r,g,b,a)` and returns a new `UColor`
   * object with the corresponding color values.
   * @param {string} RGBStr - The `RGBStr` parameter is a string representing an RGB color in the format
   * `rgba(r,g,b,a)`, where:
   * @returns {UColor} An instance of the `UColor` class with the RGB values extracted from the `RGBStr` string.
   */
  static fromRGB(RGBStr) {
    // rgba(255,61,12,0.5)')
    const splittedArray = RGBStr.split('(')
    const colorArraysStr = splittedArray[1].split(')')[0].split(',')
    const colorsArrayInt = colorArraysStr.map(color => parseFloat(color))
    return new UColor(...colorsArrayInt)
  }

  // string --- DONE !!!


  toHex() {
    const r = this.r.toString(16).padStart(2, '0');
    const g = this.g.toString(16).padStart(2, '0');
    const b = this.b.toString(16).padStart(2, '0');
    // prima 0 - 1 a 0 - 255 e poi base 16
    const a = Math.round(this.a * 255).toString(16).padStart(2, '0')
    return `#${r}${g}${b}${a}`
  }

  // string  --- DONE !!!
  /**
   * The `toRGB()` function returns the RGBA color values in a string format.
   * @returns {string} The `toRGB()` method is returning a string in the format `rgba(r, b, g, a)` where `r`,
   * `b`, `g`, and `a` are the values of the red, blue, green, and alpha components respectively of the
   * object calling the method.
   */
  toRGB() {
    return `rgba(${this.r},${this.b},${this.g}, ${this.a})`
  }

  /**
   * The function `getGrayColor` calculates the grayscale value of a color based on its RGB values.
   * @returns {UColor} A new `UColor` object is being returned with the RGB values converted to a grayscale
   * color. The RGB values are calculated based on the formula `gray = red * 0.3 + green * 0.59 + blue
   * * 0.11`, and then the grayscale value is applied to all RGB components while keeping the alpha
   * value unchanged.
   */
  getGrayColor() {
    const red = Math.round(this.r * .3) ;
    const green = Math.round(this.g * .59) ;
    const blue = Math.round(this.b * .11) ;

    const gray = red + green + blue;

    const arrayGrey = [gray, gray, gray, this.a];

    return new UColor(...arrayGrey);
  }

  getPalette() {}

  getContrastColor() {}

}

const bohColor = UColor.fromHexCode('#ff3400')
console.log(bohColor)

// const uColor1 = new UColor()
// const uColor2 = UColor.fromHexCode('#ff3400')
// const uColor3 = UColor.random()
// console.log(uColor3)
// const uColor4 = UColor.fromRGB('rgba(255,61,12,0.5)')
// const uColor4Hex = UColor.
// #ff3d0c80
// const uColor4 = UColor.fromRGB('rgba(5,21,12,0.98)')
// console.log(uColor4.toRGB())
// const uColor5 = UColor.fromRGB('rgb(255,61,12)')
// const uColor6=  UColor.fromRGB('rgb(255,61,12)')
// console.log(uColor4.toHex())
// const uColor7 = uColor4.getGrayColor()
// console.log(uColor7.toRGB());



// console.log(uColor2.toHex()) // #ff3400
// console.log(uColor2.toHex()) // rgba(255,52,0,1)
// console.log(uColor2.getContrastColor())
// console.log(uColor2.getPalette())